<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="Content-Type" content="text/html" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <!-- <meta
            http-equiv="Content-Security-Policy"
            content="default-src *" /> -->

        <!-- Icon start -->
        <link rel="icon" href="../images/icons/IconSheet.svg#browserlogo">
        <link rel="apple-touch-icon" href="../images/icons/IconSheet.svg#browserlogo">
        <link rel="shortcut icon" href="../images/icons/IconSheet.svg#browserlogo" />
        <link rel="mask-icon" href="../images/icons/IconSheet.svg#browserlogo" />
        <!-- Icon end -->

        <!-- Global site tag (gtag.js) - Google Analytics START ------------------->

        <script defer src="https://www.googletagmanager.com/gtag/js?id=G-2W1VXE5GSE"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-2W1VXE5GSE');
        </script>
        
        <!-- Global site tag (gtag.js) - Google Analytics END ---------------------->

        <!-- NO JS Behavior START -->
        <noscript>
            <style>
                nav.sidenav {display:none;}
                li.nav-item{display:none;}
            </style>
        </noscript>
         <!-- NO JS Behavior END -->

        <title>Jason Yang - Logical Foundations notes Coq + Lean</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>

    <body>
        <!-- Side navigation start -->
        <nav class="sidenav">
            <li class="logo">
                <a href="#" class="nav-link">
                    <span class="link-text logo-text">Jason</span>
                    <svg><use href="../images/icons/IconSheet.svg#sidebardod"></use></svg>
                </a>
            </li>
        
            
            <li class="nav-item">
                <a href="../tags/mathcs.html" class="nav-link">
                    <svg><use href="../images/icons/IconSheet.svg#lambda"></use></svg>
                    <span class="link-text">Math/CS</span>
                </a>
            </li>
                
            <li class="nav-item">
                <a href="../tags/prog.html" class="nav-link">
                    <svg><use href="../images/icons/IconSheet.svg#progcode"></use></svg>
                    <span class="link-text">Prog</span>
                </a>
            </li>


            <li class="nav-item">
                <a href="../tags/AI.html" class="nav-link">
                    <svg><use href="../images/icons/IconSheet.svg#AIbrain"></use></svg>
                    <span class="link-text">ML/AI</span>
                </a>
            </li>

            <li class="nav-item">
                <a href="../tags/tech.html" class="nav-link">
                    <svg><use href="../images/icons/IconSheet.svg#hardware"></use></svg>
                    <span class="link-text">Tech</span>
                </a>
            </li>

            <li class="nav-item">
                <a href="../tags/musings.html" class="nav-link">
                    <svg><use href="../images/icons/IconSheet.svg#thinker"></use></svg>
                    <span class="link-text">Musings</span>
                </a>
            </li>


            <li class="nav-item">
                <a href="https://github.com/userJY" class="nav-link">
                    <svg><use href="../images/icons/IconSheet.svg#github"></use></svg>
                    <span class="link-text">Github</span>
                </a>
            </li>
        </nav>
        <!-- Side navigation end -->
        <div id="header">
            <div id="logo">
                <a href="../">Jason Yang</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Logical Foundations notes Coq + Lean</h1>
            

            <div class="info">
    Posted on August  2, 2019
    
</div>
<div class="info">
    
    Tags: <a title="All pages tagged 'lean'." href="../tags/lean.html">lean</a>, <a title="All pages tagged 'mathcs'." href="../tags/mathcs.html">mathcs</a>
    
</div>
<div id="TOC"><ul>
<li><a href="#understanding-coq-and-lean"><span class="toc-section-number">1</span> Understanding Coq and Lean</a>
<ul>
<li><a href="#lean-variables-vs-constants"><span class="toc-section-number">1.1</span> Lean variables vs constants</a></li>
<li><a href="#inductive-dependent-types"><span class="toc-section-number">1.2</span> Inductive dependent types</a></li>
<li><a href="#coq-vs-lean"><span class="toc-section-number">1.3</span> Coq vs Lean</a>
<ul>
<li><a href="#inductive-type"><span class="toc-section-number">1.3.1</span> Inductive type</a></li>
<li><a href="#implicit"><span class="toc-section-number">1.3.2</span> Implicit</a></li>
</ul></li>
</ul></li>
<li><a href="#polymorphism"><span class="toc-section-number">2</span> Polymorphism</a></li>
<li><a href="#inductive-type-type-formation-term-intro"><span class="toc-section-number">3</span> inductive Type, Type formation, Term intro</a>
<ul>
<li><a href="#sum-type-and-product-types"><span class="toc-section-number">3.0.1</span> SUM TYPE and PRODUCT TYPES</a></li>
<li><a href="#what-is-the-meaning-of-a-proposition"><span class="toc-section-number">3.1</span> What is the meaning of a proposition</a>
<ul>
<li><a href="#harmony"><span class="toc-section-number">3.1.1</span> Harmony</a></li>
</ul></li>
</ul></li>
<li><a href="#idiosyncrasy"><span class="toc-section-number">4</span> Idiosyncrasy</a></li>
<li><a href="#pi-vs-lambda-vs-forall"><span class="toc-section-number">5</span> Pi vs Lambda vs forall</a></li>
<li><a href="#notes"><span class="toc-section-number">6</span> Notes</a></li>
</ul></div>
<section id="understanding-coq-and-lean" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Understanding Coq and Lean</h1>
<section id="lean-variables-vs-constants" class="level2" data-number="1.1">
<h2 data-number="1.1"><span class="header-section-number">1.1</span> Lean variables vs constants</h2>
<ul>
<li>variables mean free variables</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>variables <span class="dt">P</span> <span class="dt">Q</span> <span class="op">:</span> <span class="dt">Prop</span></span></code></pre></div>
</section>
<section id="inductive-dependent-types" class="level2" data-number="1.2">
<h2 data-number="1.2"><span class="header-section-number">1.2</span> Inductive dependent types</h2>
<ul>
<li><code>inductive nat: Type</code> is a plain inductive type</li>
<li><code>inductive nat (k: Type) : Type</code> is a dependent inductive type `</li>
<li><code>inductive nat : Type -&gt; Type</code> is same as above
<!--  --></li>
<li>whenever our <code>Inductive</code> associates with function type, it indicates we are using a dependent type
<ul>
<li><code>Inductive binary_word1 (n:nat) : Type</code> means that <code>binary_word1</code> takes a <code>(n:nat)</code> and returns a new type. This means the canonical types we see in the wild is <code>binary_word1 1, binary_word1 2,...</code><br />
</li>
<li><code>Inductive binary_word : nat -&gt; Type</code> shows that <code>binary_word</code> has a function type meaning it is a dependent type.</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Lean</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">--Coq (2 approaches)</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Inductive</span> binary_word1 (n<span class="op">:</span>nat) <span class="op">:</span> <span class="dt">Type</span> </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">:=</span> bwc (l <span class="op">:</span> list bool) (_ <span class="op">:</span> <span class="fu">length</span> l <span class="ot">=</span> n)<span class="op">.</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Inductive</span> binary_word <span class="op">:</span> nat <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="op">:=</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> bw_nil <span class="op">:</span> binary_word <span class="dv">0</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> bw_cons <span class="op">:</span> <span class="kw">forall</span> n, bool <span class="ot">-&gt;</span> binary_word n <span class="ot">-&gt;</span> binary_word (<span class="dt">S</span> n)<span class="op">.</span></span></code></pre></div>
</section>
<section id="coq-vs-lean" class="level2" data-number="1.3">
<h2 data-number="1.3"><span class="header-section-number">1.3</span> Coq vs Lean</h2>
<section id="inductive-type" class="level3" data-number="1.3.1">
<h3 data-number="1.3.1"><span class="header-section-number">1.3.1</span> Inductive type</h3>
<ul>
<li>Type formation diff - Coq requires specifying output type, it is optional in Lean
<ul>
<li>Lean <code>inductive prod (A B : Type) : Type</code>
<ul>
<li><code>inductive prod (A B : Type)</code> Lean can also omit the output type</li>
</ul></li>
<li>Coq <code>Inductive prod (A B : Type) : Type</code></li>
</ul></li>
<li>Term introduction/ constructors - Lean makes the type implicit, Coq makes it explicit
<ul>
<li>Lean <code>mk 2 4 :: prod nat nat</code></li>
<li>Coq <code>mk nat nat 2 4 :: prod nat nat</code></li>
</ul></li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>namespace hidden </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>inductive prod (<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Type</span>) <span class="op">:</span> <span class="dt">Type</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> mk <span class="op">:</span> <span class="dt">A</span> → <span class="dt">B</span> → prod</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>open prod</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#check mk 2 4 </span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- mk 2 4 :: prod nat nat</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>inductive prod (<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Type</span>) <span class="co">--Output type omitted</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> mk <span class="op">:</span> <span class="dt">A</span> → <span class="dt">B</span> → prod</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>end hidden</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>                          <span class="co">-- DIF--</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Inductive</span> prod (<span class="dt">A</span> <span class="dt">B</span><span class="op">:</span> <span class="dt">Type</span>) <span class="op">:</span> <span class="dt">Type</span> <span class="op">:=</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> mk (x<span class="op">:</span><span class="dt">A</span>) (y<span class="op">:</span><span class="dt">B</span>) <span class="op">.</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Check</span> mk nat nat <span class="dv">2</span> <span class="dv">4</span><span class="op">.</span> <span class="co">--notice how this diff from Lean's mk</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">--we can also add typing to our term intro/constructor</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Inductive</span> prod (<span class="dt">A</span> <span class="dt">B</span><span class="op">:</span><span class="dt">Type</span>) <span class="op">:</span> <span class="dt">Type</span> <span class="op">:=</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> pair (x<span class="op">:</span><span class="dt">A</span>) (y<span class="op">:</span><span class="dt">B</span>) <span class="op">:</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">B</span> <span class="ot">-&gt;</span> prod <span class="dt">A</span> <span class="dt">B</span><span class="op">.</span></span></code></pre></div>
<p>A more closer lean analogy to coq’s prod is below</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>inductive prod <span class="op">:</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="dv">1</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> mk <span class="op">:</span> Π (α β <span class="op">:</span> <span class="dt">Type</span>), α → β → prod α β</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#check mk nat nat 2 4 </span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">--mk nat nat 2 4 :: prod ℕ ℕ</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#check mk</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co">--mk :: Π (α β : Type), α → β → prod α β</span></span></code></pre></div>
<p>which we can also mimic in coq</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Inductive</span> prod <span class="op">:</span>  <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="op">:=</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> mk <span class="op">:</span> <span class="kw">forall</span> <span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span><span class="dt">Type</span> , <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">B</span> <span class="ot">-&gt;</span> prod <span class="dt">A</span> <span class="dt">B</span> <span class="op">.</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Check</span> pair nat nat <span class="dv">2</span> <span class="dv">4</span><span class="op">.</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>(<span class="op">*</span>  pair nat nat <span class="dv">2</span> <span class="dv">4</span><span class="ot"> ::</span> prod nat nat <span class="op">*</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Check</span> mk<span class="op">.</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>(<span class="op">*</span><span class="ot"> mk ::</span> <span class="kw">forall</span> <span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Type</span>, <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">B</span> <span class="ot">-&gt;</span> prod <span class="dt">A</span> <span class="dt">B</span> <span class="op">*</span>)</span></code></pre></div>
</section>
<section id="implicit" class="level3" data-number="1.3.2">
<h3 data-number="1.3.2"><span class="header-section-number">1.3.2</span> Implicit</h3>
<ul>
<li>Notice how with <code>(A B : Type)</code> the result of <code>mk 2 4 :: prod A B</code></li>
<li>But with <code>{A B : Type}</code> the result of <code>mk 2 4 :: prod</code> meaning this is not a dependent type</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>inductive prodB {<span class="dt">A</span> <span class="dt">B</span><span class="op">:</span> <span class="dt">Type</span>} <span class="op">:</span> <span class="dt">Type</span> </span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> mk <span class="op">:</span> <span class="dt">A</span> → <span class="dt">B</span> → prodB </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#check mk 2 4</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- mk 2 4 :: prod</span></span></code></pre></div>
<p>coq</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Inductive</span> prod {<span class="dt">A</span> <span class="dt">B</span><span class="op">:</span> <span class="dt">Type</span>} <span class="op">:</span> <span class="dt">Type</span> <span class="op">:=</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> mk (x<span class="op">:</span><span class="dt">A</span>) (y<span class="op">:</span><span class="dt">B</span>) <span class="op">.</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Check</span> mk <span class="dv">2</span> <span class="dv">4</span><span class="op">.</span> </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>(<span class="op">*</span> mk <span class="dv">2</span> <span class="dv">4</span><span class="ot"> ::</span> prod     <span class="op">*</span>)</span></code></pre></div>
</section>
</section>
</section>
<section id="polymorphism" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Polymorphism</h1>
<p>in C++ we have <code>vector&lt;int&gt;</code> as the type for a list of int. For a polymorphic list, we have <code>vector&lt;T&gt;</code> which is really a dependent type <code>Π( T : Type*) -&gt;  vector T</code></p>
<div class="sourceCode" id="cb9" data-filename="coq"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Inductive</span> natlist <span class="op">:</span> <span class="dt">Type</span> <span class="op">:=</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> nil</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> cons (n <span class="op">:</span> nat) (l <span class="op">:</span> natlist)<span class="op">.</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>(<span class="op">**</span> <span class="dt">For</span> example, here is a three<span class="op">-</span>element list<span class="op">:</span> <span class="op">*</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Definition</span> mylist <span class="op">:=</span> cons <span class="dv">1</span> (cons <span class="dv">2</span> (cons <span class="dv">3</span> nil))<span class="op">.</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="dt">Check</span> mylist<span class="op">.</span></span></code></pre></div>
<p><span class="math display">\[\cfrac{}{\vdash nil : natlist} \qquad \cfrac{\vdash n: nat \qquad \vdash l:natlist}{\vdash cons\ n\ l : natlist}\]</span></p>
</section>
<section id="inductive-type-type-formation-term-intro" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> inductive Type, Type formation, Term intro</h1>
<ul>
<li>fst and snd projection functions are canonical functions of the product type</li>
</ul>
<!--  -->
<ul>
<li>Type formation and Term introduction rules are inside the <code>Inductive</code> type keyword
<span class="math display">\[\cfrac{}{\vdash False : Prop} \tag{type formation}\]</span>
<span class="math display">\[\text{There is no term intro for False} \tag{term intro}\]</span></li>
</ul>
<div class="sourceCode" id="cb10" data-filename="False.coq"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Inductive</span> <span class="dt">False</span> <span class="op">:</span> <span class="dt">Prop</span><span class="op">.</span></span></code></pre></div>
<p><span class="math display">\[\cfrac{}{\vdash True : Prop} \tag{type formation}\]</span>
<span class="math display">\[\cfrac{}{\vdash top : True} \tag{term intro}\]</span></p>
<div class="sourceCode" id="cb11" data-filename="True.coq"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Inductive</span> <span class="dt">True</span> <span class="op">:</span> <span class="dt">Prop</span> <span class="op">:=</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> top <span class="op">:</span> <span class="dt">True</span><span class="op">.</span></span></code></pre></div>
<p><span class="math display">\[\cfrac{\vdash P : Prop \qquad \vdash Q : Prop}{\vdash and\ P\ Q : Prop} \tag{type formation}\]</span></p>
<p><span class="math display">\[\cfrac{\vdash x : P \qquad \vdash y : Q}{\vdash conj\  x\ y\ : and\ P\ Q} \tag{term intro}\]</span></p>
<ul>
<li>term Elimination for Sum type is Pattern matching in Haskell, Coq,</li>
</ul>
<p><span class="math display">\[\cfrac{\vdash p: A + B \qquad  x: A \vdash v_A : C \qquad y : B \vdash v_B : C }{match(p,x.v_A,y.v_B):C} \tag{term elim}\]</span></p>
<div class="sourceCode" id="cb12" data-filename="and.coq"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Inductive</span> <span class="fu">and</span> (<span class="dt">P</span> <span class="dt">Q</span> <span class="op">:</span> <span class="dt">Prop</span>) <span class="op">:</span> <span class="dt">Prop</span> <span class="op">:=</span> <span class="co">--Type formation</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> conj <span class="op">:</span> <span class="dt">P</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="ot">-&gt;</span> <span class="fu">and</span> <span class="dt">P</span> <span class="dt">Q</span><span class="op">.</span> <span class="co">--Term introduction</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Check</span> conj <span class="dt">True</span> <span class="dt">True</span> <span class="dt">Top</span> <span class="dt">Top</span><span class="op">.</span></span></code></pre></div>
<ul>
<li>Notice we have to do <code>conj nat nat 2 4</code> NOT <code>Check conj 2 4.</code> because we actually defined a dependent type.
<ul>
<li><code>conj :: Π(P : Prop) -&gt;  Π(Q : Prop) -&gt; P -&gt; Q</code></li>
</ul></li>
</ul>
<div class="sourceCode" id="cb13" data-filename="logic.lean"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>inductive falseN <span class="op">:</span> <span class="dt">Prop</span> <span class="co">--no intro rules for Bottom Type</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>inductive trueN <span class="op">:</span> <span class="dt">Prop</span> <span class="co">--only 1 intro rule for Top</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> introT <span class="op">:</span> trueN</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co">--  ------</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co">--    T</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>inductive andN (a b <span class="op">:</span> <span class="dt">Prop</span>) <span class="op">:</span> <span class="dt">Prop</span> </span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> introConj <span class="op">:</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> andN</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="co">--   a  b</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- --------</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="co">--  a ∧ b</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a> inductive orN (a b <span class="op">:</span> <span class="dt">Prop</span>) <span class="op">:</span> <span class="dt">Prop</span> </span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> intro_left<span class="op">:</span> a <span class="ot">-&gt;</span> orN </span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> intro_right<span class="op">:</span> b <span class="ot">-&gt;</span> orN</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="co">--     a          b</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="co">--  --------   -------</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="co">--   a ∨ b     a ∨ b</span></span></code></pre></div>
<div class="sourceCode" id="cb14" data-filename="logic.v"><pre class="sourceCode v"><code class="sourceCode verilog"></code></pre></div>
<section id="sum-type-and-product-types" class="level3" data-number="3.0.1">
<h3 data-number="3.0.1"><span class="header-section-number">3.0.1</span> SUM TYPE and PRODUCT TYPES</h3>
<p>use inductive keyword to create intro rules
use def or function definitions to create elim rules</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>universes j k </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>inductive <span class="dt">ProdN</span> (a <span class="op">:</span> <span class="dt">Type</span> j) (b <span class="op">:</span> <span class="dt">Type</span> k) </span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> pair <span class="op">:</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">ProdN</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>inductive <span class="dt">Either</span> (a <span class="op">:</span> <span class="dt">Type</span> j) (b <span class="op">:</span> <span class="dt">Type</span> k)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> inl <span class="op">:</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> </span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> inr <span class="op">:</span> b <span class="ot">-&gt;</span> <span class="dt">Either</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>def <span class="dt">EitherElim</span> <span class="op">:</span>  (<span class="dt">Either</span> nat string) <span class="ot">-&gt;</span> nat  </span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="op">|</span> (inl <span class="dv">4</span>)  <span class="op">:=</span> <span class="dv">6</span> </span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>open <span class="dt">ProdN</span> </span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>open <span class="dt">Either</span> </span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="pp">#check pair nat char </span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- pair ℕ char : prodN Type Type</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a><span class="pp">#check inl nat</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a><span class="co">--inl ℕ : Either Type ?M_1</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a><span class="pp">#check@ inl nat </span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a><span class="co">--inl : Π {b : Type u_1}, ℕ → Either ℕ b</span></span></code></pre></div>
<p>in haskell</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Either</span> a b <span class="ot">=</span> <span class="dt">Left</span> a <span class="op">|</span> <span class="dt">Right</span> b</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Left</span><span class="ot"> nat ::</span> <span class="dt">Either</span> nat <span class="dt">M</span><span class="op">?</span> </span></code></pre></div>
</section>
<section id="what-is-the-meaning-of-a-proposition" class="level2" data-number="3.1">
<h2 data-number="3.1"><span class="header-section-number">3.1</span> What is the meaning of a proposition</h2>
<ul>
<li>To understand meaning we need to combine duality of Verificationist and Pragmatist
<ul>
<li>Verificationist tells us meaning is defined by how it is built.
<ul>
<li>The meaning of a proposition is precisely the components or nodes that build it</li>
<li>Verificationist owns the Intro rules</li>
</ul></li>
<li>Pragmatist tells us meaning is defined by how it is deconstructed.
<ul>
<li>The meaning of a proposition is precisely the things we can conclude from the proposition</li>
<li>Pragmatist owns the Elim rules</li>
</ul></li>
</ul></li>
</ul>
<section id="harmony" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1"><span class="header-section-number">3.1.1</span> Harmony</h3>
<!--  -->
<ul>
<li>Verificationist
<ul>
<li>intro then elim, then reduce the proof tree
<ul>
<li>the resulting proof tree lacks elim rules
<!--  --></li>
</ul></li>
</ul></li>
<li>Pragmatist
<ul>
<li>elim then intro, then reduce the proof tree
<ul>
<li>the resulting proof tree lack intro rules</li>
</ul></li>
</ul></li>
</ul>
</section>
</section>
</section>
<section id="idiosyncrasy" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Idiosyncrasy</h1>
<ul>
<li>Coq will give an error for the below</li>
</ul>
<div class="sourceCode" id="cb17"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Inductive</span> <span class="fu">and</span> <span class="op">:</span> <span class="dt">Prop</span> <span class="ot">-&gt;</span> <span class="dt">Prop</span> <span class="ot">-&gt;</span> <span class="dt">Prop</span> <span class="op">:=</span> </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> introConj (a<span class="op">:</span> <span class="dt">Prop</span>) (b<span class="op">:</span><span class="dt">Prop</span>) <span class="op">:</span> <span class="fu">and</span><span class="op">.</span></span></code></pre></div>
<ul>
<li>We need to push back the props</li>
</ul>
<div class="sourceCode" id="cb18"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Inductive</span> <span class="fu">and</span> (<span class="dt">P</span> <span class="dt">Q</span> <span class="op">:</span> <span class="dt">Prop</span>) <span class="op">:</span> <span class="dt">Prop</span> <span class="op">:=</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> introConj <span class="op">:</span> <span class="dt">P</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="ot">-&gt;</span> <span class="fu">and</span> <span class="dt">P</span> <span class="dt">Q</span><span class="op">.</span></span></code></pre></div>
</section>
<section id="pi-vs-lambda-vs-forall" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Pi vs Lambda vs forall</h1>
<div class="sourceCode" id="cb19"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>def injective {<span class="dt">A</span> <span class="dt">B</span>} (f<span class="op">:</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">B</span>) <span class="op">:=</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  Π x y <span class="op">:</span> <span class="dt">A</span>, f x <span class="ot">=</span> f y <span class="ot">-&gt;</span> x <span class="ot">=</span> y</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>def injective {<span class="dt">A</span> <span class="dt">B</span>} (f<span class="op">:</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">B</span>) <span class="op">:=</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  ∀ x y <span class="op">:</span> <span class="dt">A</span>, f x <span class="ot">=</span> f y <span class="ot">-&gt;</span> x <span class="ot">=</span> y</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>def injective {<span class="dt">A</span> <span class="dt">B</span>} (f<span class="op">:</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">B</span>) <span class="op">:=</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  λ x y <span class="op">:</span> <span class="dt">A</span>, f x <span class="ot">=</span> f y <span class="ot">-&gt;</span> x <span class="ot">=</span> y</span></code></pre></div>
</section>
<section id="notes" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Notes</h1>
<p>Poly</p>
<p>Polymorphic inductive type definition aka Inductive + Dependent types</p>
<p>implicit args</p>
<p>Because X is declared as implicit for the entire inductive definition including list’ itself, we now have to write just list’ whether we are talking about lists of numbers or booleans or anything else, rather than list’ nat or list’ bool or whatever; this is a step too far.</p>
<p>Tactics</p>
<p>All constructors/ term intro are injective aka rules that take arguments like successor takes argument n to make S n, and if S m = S n then n = m. Constructors that take no arguments are trivilaly injective like nil in list or 0 in nat.</p>
</section>

        </div>
        <div id="footer">
            <div class="flex-container" style="display:flex; justify-content: space-between;">
                <div>
                    Site proudly generated by
                    <a href="http://jaspervdj.be/hakyll">Hakyll</a>
                </div>
                <div class="pagehitscounter"> 
                    <img src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fuserjy.github.io&count_bg=%231FDBD9&title_bg=%23555555&icon=&icon_color=%23E7E7E7&title=hits&edge_flat=true" />
                </div>
                <div xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/"><a property="dct:title" rel="cc:attributionURL" href="https://userjy.github.io/">Jason's Notes</a> by <a rel="cc:attributionURL dct:creator" property="cc:attributionName" href="https://userjy.github.io/">Jason Yang</a> is licensed under <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-NC-ND 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nd.svg?ref=chooser-v1"></a></div>
  
            </div>
        </div>
        
    </body>
    <footer>
        <!-- CODE TAB START -->
        <script>
                    //Structure:
                    // Codeblock < Group/Grouplabel/subgrp < datagroupSet < allblocks

            const AllBlocksPre = document.querySelectorAll("[data-group]");
            const AllBlocks = [...AllBlocksPre]; //gets all codeblocks w/ and w/o group label
            const getUniqueSet = (TargetSet,dataAttr) => {
                //gets the set of attributes of an array of codeblocks aka TargetSet
                const temp = TargetSet.map((e) => (e.getAttribute(dataAttr))); 
                const temp2 = temp.filter((a)=>a); //remove nulls
                return [...new Set(temp2)];
            } 
            const datagroupSet = getUniqueSet(AllBlocks,"data-group") //remove nulls

            const getCodeBlocks = (datagroup) => {
                //return list of glabels CodeBlocks associated to a single group 
                return AllBlocks.filter((dataglabelBlock)=>(dataglabelBlock.getAttribute("data-group") === datagroup));
            }

            const showBlocks = (dataglabeltxt,datagroupCodeBlocks) => {
                const selectedglabelGroup = datagroupCodeBlocks.filter((SingleBlock)=>(SingleBlock.getAttribute("data-glabel") === dataglabeltxt))
                const NONselectedglabelGroup = datagroupCodeBlocks.filter((SingleBlock)=>(SingleBlock.getAttribute("data-glabel") !== dataglabeltxt))
                selectedglabelGroup.map((SingleBlock) => (SingleBlock.style.display="block"));
                (NONselectedglabelGroup || []).map((SingleBlock) => (SingleBlock.style.display="none"));
            }
            const mkBtn = (dataglabeltxt,datagroupCodeBlocks,showfunc) => {
                const newbutton = document.createElement("input");
                newbutton.type = "radio";
                // newbutton.textContent = dataglabeltxt;
                newbutton.addEventListener('click', ()=>{
                    // console.log(datagroupCodeBlocks)
                    showfunc(dataglabeltxt,datagroupCodeBlocks);
                });
                return newbutton;
            }
            const showAll = (datagroup) => {
                //make all codeblocks visible
            datagroup.map((e)=>(e.style.display="block"));
            }

            const buildCodeTab = (datagroupCodeBlocks,datagroup) => {
                const leaderCodeBlockDiv = datagroupCodeBlocks[0]; //get the leader codeblock of a group of codeblock
                const setglabelstxt = getUniqueSet(datagroupCodeBlocks,"data-glabel"); 
                setglabelstxt.map((singleglabeltxt)=>{
                    
                    const btn = mkBtn(singleglabeltxt,datagroupCodeBlocks,showBlocks);
                    btn.name = datagroup;
                    btn.id = datagroup+singleglabeltxt;
                    const radiolabelx = document.createElement("label");
                    radiolabelx.setAttribute("for",datagroup+singleglabeltxt);
                    radiolabelx.innerText = singleglabeltxt;
        
                    // leaderCodeBlockDiv.insertAdjacentElement("beforebegin",radiolabelx);
                    // radiolabelx.appendChild(btn);
                    const radioclass = document.createElement("div");
                    radioclass.className = "radioclass";
                    radioclass.appendChild(btn);
                    radioclass.appendChild(radiolabelx)
                    leaderCodeBlockDiv.insertAdjacentElement("beforebegin",radioclass);
                    // leaderCodeBlockDiv.prepend(btn);
                    
                    
                })
             
                // leaderCodeBlockDiv.append(btnlist);
                
                const btnShowAll = document.createElement("input");
                btnShowAll.type = "radio";
                btnShowAll.addEventListener('click',(e)=>(showAll(datagroupCodeBlocks)));

                btnShowAll.name = datagroup;
                btnShowAll.id = datagroup+"All";
                const radiolabel = document.createElement("label");
                radiolabel.setAttribute("for",datagroup+"All");
                radiolabel.innerText = "All";

                const radioclass = document.createElement("div");
                radioclass.className = "radioclass";
                radioclass.appendChild(btnShowAll);
                radioclass.appendChild(radiolabel)
                leaderCodeBlockDiv.insertAdjacentElement('beforebegin',radioclass);
                //make showAllbutton END
            }

            //below code is performing actual behavior, the above code are just functions
            datagroupSet.map((datagroup) => {
                
                const groupOfCodeblocks = getCodeBlocks(datagroup);
                buildCodeTab(groupOfCodeblocks,datagroup);
                const firsttab = groupOfCodeblocks[0];
                showBlocks(firsttab.getAttribute("data-glabel"),groupOfCodeblocks);
       
            })
        </script>
        <!-- CODE TAB END ---->

        <!-- MATH JAX START -------------------------------------- -->
        <script id="MathJax-script" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-chtml.min.js">
        </script>
        <!-- MATH JAX END ----------------------------------------- -->
        <!-- MERMAID START -------------------------------------- -->
        <script type="module"> 
            import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/+esm'
        </script>
        <!-- <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js" async></script> -->
        <!-- MERMAID END -------------------------------------- -->
        <!-- RAILROAD START -------------------------------------- -->
        <script type="module">
            import rr,* as rrClass from "/lib/railroad/railroad.js";
            Object.assign(window,rr)
            window.rrOptions = rrClass.Options;
            document.addEventListener('DOMContentLoaded',()=>{ReplaceDivWithSvg()},false)
            const ReplaceDivWithSvg = () =>  {
                for (const railroadelem of document.getElementsByClassName("rroad") ){
                railroadelem.innerHTML = eval(railroadelem.innerText.trim()+".toString()")
                }
            }
        </script>
        

        <link rel="stylesheet" href="../lib/railroad/railroad-diagrams.css">
        <!-- RAILROAD END ----------------------------------------- -->
    </footer>
</html>
