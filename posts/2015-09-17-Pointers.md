---
title: C Pointers
tags: prog, C
---

$$ Address \rightarrow Value $$
$$ Pointer \rightarrow Address \rightarrow Value $$

$$ p = &x \equiv *p = x $$
$$ arr + i = &arr[i] $$

* *(arr + i) = arr[i]
* *arr = arr[0]
* **arr = arr[0][0]

* pass-by-pointer vs pass-by-ref
  * pass-by-pointer when you need a NULL placeholder.
* the way to use pass-by-ref is similar to pass-by-value  
* pass-by-pointer requires passing an address

All variables are pointers
All languages do implicit dereference of variables.
C allows the option to make it explicit with pointers.


```C
//pass-by-pointer
int &x = ...;
void func(*p){
  p = x;
}

//pass-by-ref
int x = ...;
void func(&p){
  p = x;
}
```


# 'any' Type



```hs
Address :: Type
Any :: Type

(T -> Any) == Address

ptr :: (T -> Any)

--in haskell
Linkedlist Int = Int + (LinkedList Int)
--in C++
Linkedlist Int = Int + (T -> Any)
```

$$(T \rightarrow Any) = Any^T = Any$$

```hs
--Type of a dereferenced pointer

--initialize a pointer
ptr :: (T -> Any) --haskell
int* ptr; --C++


--dereference
*ptr :: Any --haskell
*ptr; --C++
```
