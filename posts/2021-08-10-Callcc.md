---
title: Callcc
tags: prog, cloud, frontend
---

# Investigating callcc

* `((a ->b) -> a*) -> a`
* `cont :: (a ->b)` the power of having the continuation as a function or as the bound lambda variable is that we don't actually have to use the continuation.
  * `lambda cont. 3 :: (a -> b) -> Int` notice it doesnt matter what out `cont` is, we just return 3 regardless
* `a*` can be considered the hole to be filled. in  `2 + callcc...`, the hole of the `2 + []` is an Int.

```bash
   +
  / \
 2   @
    /  \
callcc  lambda cont.
         |
         @
        / \
      cont 3
```
```bash    
(+2 (callcc (lambda (cont) 3 )))
> 5
```

* in the above case we never used the continuation
* `(lambda (cont) 3 ) :: ? -> ?`
* `callcc :: (?-> ?) -> Int`
  * note that `(? -> ?)` can also be `((? -> ?) -> ?)`
* `(callcc (lambda (cont) 3 )) :: Int ` since we know this expr return 3 for the output to be 5


```
(+ 2 (callcc (lambda cont (cont 3) 6 )))
(+ 2 3)
```

* `callcc :: ((a -> b) -> a) -> a`
* `cont :: (Int -> b)`
* `cont 3 :: Int`
* `lambda cont (cont 3) :: (Int -> b) -> Int` 

# Continuation return beta

* `cont x :: b` 
  * this means we can apply any operation on `sq(cont x) :: Nat` `str(cont x) :: Bool` and the type can be anything but since continuation is like an early return, it doesn't do anything meaningful but change the type.

# The only type that really matters it the first a

* `callcc :: ((a ...`
  * The first `a` is basically the save point and it determines the third and forth `a`.



